<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3c.org/TR/xhtml1/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/XHTML" xml:lang="it" lang="it">
	<head>
        <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
        <link rel="stylesheet" href="index.css"/>

		<title>
			Scondo Progetto i3Dg 2018 - Prod. visualization
		</title>
	</head>

	<body>
        <div id="myNav" class="overlay">
            <a class="overlayTitle">Settaggi</a>
            <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
            <div class="overlay-content">
                <button id="military" class="btn btnDisabled" onClick="javascript:change('mat1', 'becco');">Military</button>
                <button id="rust" class="btn" onClick="javascript:change('copper', 'becco');">Rust</button>
            </div>
        </div>

        <button id="menuBtn" class="btn menuBtn" onclick="openNav()">&#9776; Settaggi </button>
        <button id="menuBtn" class="btn menuBtnOrder" onclick="">Compra ora!</button>

        <!-- ********** robot ************ -->

        <script src="lib/three.min.js"></script>
    		<script src="lib/stats.min.js"></script>
    		<script src="lib/OrbitControls.js"></script>
    		<script src='lib/dat.gui.min.js'></script>
    		<script src="lib/GLTFLoader.js"></script>


		<!-- shaders -->

		<script type="text/x-glsl" id="vertex">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

		<script type="text/x-glsl" id="fragment">

			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 uVv;

			uniform vec3 pointLightPosition1; // in world space
      uniform vec3 pointLightPosition2; // in world space
			uniform vec3 clight1;
      uniform vec3 clight1;

			uniform sampler2D baseColor;
      uniform sampler2D diffuseMap;
			uniform sampler2D heightMap;
      uniform sampler2D metallicMap;
      uniform sampler2D normalMap;
			uniform sampler2D roughnessMap;
      uniform sampler2D specularMap;

			uniform samplerCube irradianceMap;
			uniform samplerCube envMap;

			const float PI = 3.14159;

      #extension GL_OES_standard_derivatives : enable

      
      vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

		  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

			vec3 q0 = dFdx( eye_pos.xyz );
			vec3 q1 = dFdy( eye_pos.xyz );
			vec2 st0 = dFdx( uVv.st );
			vec2 st1 = dFdy( uVv.st );

			vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
			vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
			vec3 N =  surf_norm ;

			vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
			mapN.xy = normalScale * mapN.xy;
			mat3 tsn = mat3( S, T, N );
			return normalize( tsn * mapN );

		}

		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
		vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
			return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
		}

			void main() {
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 v = normalize( -vPosition);
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				// small quantity to prevent divisions by 0
				float nDotv = max(dot( n, v ),0.000001);
				vec3 fresnel = FSchlick(nDotv);
				// negate x to account for how cubemap is displayed on background
				vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
				// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));
				vec3 outRadiance = fresnel*envLight;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

		</script>

		<!-- three.js code -->

		<script>

			var renderer = new THREE.WebGLRenderer( { antialias: true } );
			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
			var scene = new THREE.Scene();
      var controls = new THREE.OrbitControls( camera, renderer.domElement );
      //LOADER MODELLO GLTF
      var loader = new THREE.GLTFLoader();
      //Array di 8 stringhe contenenti i nomi dei figli dell'oggetto GLTF
      var objNames = ["becco","disegno","disegno","disegno","disegno","disegno","elmo","visiera"];


			// loaders cubemap/envMap/texture
			var cubeMapLoader = new THREE.CubeTextureLoader();
      var tLoader = new THREE.TextureLoader();

			// load irradiance map
			cubeMapLoader.setPath( 'irradianceMap/vanc/' );
			var irradianceMap = cubeMapLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );
      // Load background cube map
      cubeMapLoader.setPath( 'envMap/vanc/' );
			var envMap = cubeMapLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );
      scene.background = envMap;
			envMap.minFilter = THREE.LinearMipMapLinearFilter;


      //********* MATERIALI **************************
      vs = document.getElementById("vertex").textContent;
			fs = document.getElementById("fragment").textContent;

      //DEFINIZIONE MATERIALI PERSONALIZZATI
      materialExtensions = {
        derivatives: true, //set to use derivatives
        shaderTextureLOD: true //set to use shader texture LOD
      }

      // carbonio
      var carbPath = "textures/carbonFiber/";
      var fiberUniforms = {
        baseColor: {type: "t", value: loadTexture(carbPath + "albedo.png")},
        heightMap: {type: "t", value: loadTexture(carbPath + "heightMap.png")},
        metalness: {type: "t", value: loadTexture(carbPath + "metalness.png")},
        normalMap: {type: "t", value: loadTexture(carbPath + "normalMap.png")},
        normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
        roughness: {type: "t", value: loadTexture(carbPath + "roughness.png")},
        pointLightPosition1: {type: "v3", value: new THREE.Vector3(10.0,10.0,-10.0)},
        pointLightPosition2: {type: "v3", value: new THREE.Vector3(-10.0,10.0,10.0)},
        clight1: {type: "v3", value: new THREE.Vector3(1.0,1.0,1.0)},
        clight2: {type: "v3", value: new THREE.Vector3(0.5,0.5,0.5)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
      }
      //var carbonFiber = new THREE.ShaderMaterial({uniform: fiberUniforms, vertexShader: vs, fragmentShader: fs, extensions: materialExtensions});
      /*var carbonFiber = new THREE.MeshStandardMaterial({map: loadTexture(carbPath + "albedo.png"),
                                                        envMap: envMap,
                                                        side: THREE.FrontSide,
                                                        metalnessMap: loadTexture(carbPath + "metalness.png"),
                                                        //normalMap: tLoader.load("textures/carbonFib/normalMap.png"),
                                                        roughnessMap: loadTexture(carbPath + "roughness.png")
                                                      });*/

      // rame
      var coPath = 'textures/copper/';
      var copperUniforms = {
        baseColor: {type: "t", value: loadTexture(coPath + "baseColor.png")},
        diffuseMap: {type: "t", value: loadTexture(coPath + "diffuse.png")},
        glossMap: {type: "t", value: loadTexture(coPath + "glossiness.png")},
        heightMap: {type: "t", value: loadTexture(coPath + "heightMap.png")},
        metallicMap: {type: "t", value: loadTexture(coPath + "metallic.png")},
        normalMap: {type: "t", value: loadTexture(coPath + "normal.png")},
        roughnessMap: {type: "t", value: loadTexture(coPath + "roughness.png")},
        specularMap: {type: "t", value: loadTexture(coPath + "specular.png")},
        pointLightPosition1: {type: "v3", value: new THREE.Vector3(10.0,10.0,-10.0)},
        pointLightPosition2: {type: "v3", value: new THREE.Vector3(-10.0,10.0,10.0)},
        clight1: {type: "v3", value: new THREE.Vector3(1.0,1.0,1.0)},
        clight2: {type: "v3", value: new THREE.Vector3(0.5,0.5,0.5)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}

      }
      var copper = new THREE.ShaderMaterial({uniform: copperUniforms, vertexShader: vs, fragmentShader: fs, extensions: materialExtensions});
      /*var copper = new THREE.MeshStandardMaterial({map: tLoader.load(coPath + 'albedo.png'),
                                                  envMap: envMap,
                                                  metalness: 0.8,
                                                  displacementMap: tLoader.load(coPath + 'heightMap.png'),
                                                  displacementScale: 0.01,
                                                  roughnessMap: tLoader.load(coPath + 'roughness.png'),
                                                  side: THREE.DoubleSide});*/
    // oro
    var gPath = 'textures/gold/';
    var fiberUniforms = {
      baseColor: {type: "t", value: loadTexture(gPath + "albedo.jpg")},
      metalness: {type: "t", value: loadTexture(gPath + "metalness.jpg")},
      normalMap: {type: "t", value: loadTexture(gPath + "normal.jpg")},
      normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
      roughness: {type: "t", value: loadTexture(gPath + "roughness.jpg")},
      pointLightPosition1: {type: "v3", value: new THREE.Vector3(10.0,10.0,-10.0)},
      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-10.0,10.0,10.0)},
      clight1: {type: "v3", value: new THREE.Vector3(1.0,1.0,1.0)},
      clight2: {type: "v3", value: new THREE.Vector3(0.5,0.5,0.5)},
      envMap: {type: "t", value: envMap},
      iEM: {type: "t", value: irradianceMap}
    }
    //var gold = new THREE.ShaderMaterial({uniform: copperUniforms, vertexShader: vs, fragmentShader: fs, extensions: materialExtensions});
    /*var gold = new THREE.MeshStandardMaterial({map:loadTexture(gPath + 'albedo.jpg'),
                                                envMap: envMap,
                                                metalnessMap:loadTexture(gPath + 'metalness.jpg'),
                                                //normalMap: loadTexture("textures/gold/normal.jpg"),
                                                roughnessMap: loadTexture(gPath + 'roughness.jpg'),
                                                side: THREE.DoubleSide});*/

      var mat1 = new THREE.MeshStandardMaterial({color: 0xeeeeee,
                                                metalness: 0.8,
                                                roughness: 0.3,
                                                envMap: envMap,
                                                side: THREE.DoubleSide});

      var mat2 = new THREE.MeshStandardMaterial({color: 0xee8830,
                                                metalness: 0.8,
                                                roughness: 0.3,
                                                envMap: envMap,
                                                side: THREE.DoubleSide});

      // Materiale standard per la visiera
      var redGlass = new THREE.MeshStandardMaterial({ color: 0xcc3030,
                                                      opacity: 0.9,
                                                      transparent: true,
                                                      side: THREE.DoubleSide});

      //******** lights ****************************


      var light1 = new THREE.PointLight( 0xffffff, 1, 100 );
      light1.position.set( 10, 10, -10 );
      scene.add( light1 );
      // Luce Standard appositamente per la visiera
      var light2 = new THREE.PointLight( 0xffffff, 0.5, 100 );
      light2.position.set( -10, 10, 10 );
      scene.add( light2 );


			function loadTexture(file) {
					var texture = tLoader.load( file , function ( texture ) {
						texture.minFilter = THREE.LinearMipMapLinearFilter;
						texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
						texture.offset.set(0, 0);
						texture.needsUpdate = true;
						render();
					} )
					return texture;
			}

      function retriveMaterial(matName){

        switch(matName){
          case 'copper': return copper;
          case 'oro': return oro;
          case 'mat1': return mat1;
          default: return mat2;
        }
      }

      function change(mat, part){
        applyMaterial(retriveMaterial(mat), part);
      }

      function applyMaterial(material, name){

        //Un po di debugging
        console.log("scene length: " + scene.children.length);

        for(let i = 0; i < scene.children.length; i++){
          console.log("figlio scena n.ro: " + i);
          console.log( scene.children[i]);
        }


        let b = 0;
        let obj = scene.children[scene.children - 1];    //indicizzo il modello gltf
        console.log("Ho caricato: " + obj);

        if(obj == undefined){
          return;
        }

        console.log("Entro nel While");
        while(!(obj.children.length == 8)){ //finchè non arrivo al nodo radice delle mesh
          console.log("for n.ro: " + b);
          obj = obj.children[0];
          b++;
        }
        for(let i = 0; i < obj.children.length; i++){
          console.log("passo n.ro: " + i);
          if(obj.children[0].children[0].name == name){ //accedo al nipote, che contiene la mesh
            console.log("trovato figlio!!");
            obj.children[0].children[0].material = material;
          }
        }
        render();
      }

      function loadModel(){

        loader.load('kylo_ren_helmet/scene.gltf', function(gltf){
          let i = 0;
          gltf.scene.traverse( function ( child ) {
            if(child.isMesh){

                child.name = objNames[i];
                console.log(child.name);
                if(child.name == 'visiera'){
                  child.material = redGlass;
                }else{
                  child.material = copper;
                }
                i++;
            }
          });
          scene.add(gltf.scene);
        });

      }


			function init() {

        loadModel();

				renderer.setClearColor( 0xf0f0f0 );

				camera.position.set( 20, 10, 15 );
				camera.lookAt(0,0,0);

				scene.add(camera);

        controls.minDistance = 1;
				controls.maxDistance = 30;
				controls.enablePan = true; //TODO: mettere false alla fine
				controls.update();

				document.body.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				window.addEventListener( 'resize', onResize, false );

      }


			function onResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}


			function update() {
				requestAnimationFrame( update );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

      init();
      update();
      render();

  // *****************************


  function openNav() {
      document.getElementById("myNav").style.width = "220px";
      document.getElementById("menuBtn").style.visibility = "hidden";
  }

  function closeNav() {
      document.getElementById("myNav").style.width = "0%";
      document.getElementById("menuBtn").style.visibility = "visible";
  }

  function changeMaterial(index){
      if(selected !== index){
          document.getElementById(index).classList.add("btnDisabled");
          document.getElementById(selected).classList.remove("btnDisabled");

          selected = index;
          checkLoaded(selected);

          closeNav();
      }
  }
        </script>
	</body>
</html>
